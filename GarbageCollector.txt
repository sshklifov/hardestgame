// evaluate how alike are the players
// PlayerInfo::lastpos contains the few last positions of the players. They can
// be used to determine if two players follow roughly the same strategy (a good 
// cross over pair).
int Planner::EvalMatch(const PlayerInfo& dead, const PlayerInfo& alive, int& crossIdx)
{
    /* assert(dead.dieIdx>=0 && alive.dieIdx<0); */
    /* int steps = alive.plan.size(); */
    /* assert(steps == (int)dead.plan.size()); */

    /* int aliveFirstIdx = steps+1-lastMovesSize; */
    /* int deadLastIdx = dead.dieIdx; */
    /* if (aliveFirstIdx > deadLastIdx) */
    /* { */
    /*     crossIdx = steps-1; */
    /*     return DstHeuristic(GetCenter(dead.pos), alive.lastpos[lastMovesSize-1]); */
    /* } */

    /* int aliveLastIdx = steps; */
    /* int aliveOffset = aliveLastIdx-deadLastIdx; */
    /* int cnt = deadLastIdx-aliveFirstIdx+1; */
    /* assert(aliveOffset+cnt-1 == lastMovesSize-1); */

    /* int diff = INT_MAX; */
    /* for (int i = 0; i < cnt; ++i) */
    /* { */
    /*     IPoint pointDead = dead.lastpos[i]; */
    /*     IPoint pointAlive = alive.lastpos[i + aliveOffset]; */
    /*     int dst = DstHeuristic(pointDead, pointAlive); */
    /*     if (dst < diff) */
    /*     { */
    /*         diff = dst; */
    /*         crossIdx = deadLastIdx-i; */
    /*         assert(crossIdx>= 0 && crossIdx < steps); */
    /*     } */
    /* } */

    // TODO
    /* return diff; */
    return 1e6;
}

// cross over players. always cross over the dead with the living so the dead
// can learn from the living. do not consider indices before crossIdx as they would
// be suboptimal. eg: cross over at the last steps, when the player has died in the
// begining.
void Planner::CrossOver(const PlayerInfo& dead, const PlayerInfo& alive, int crossIdx, PlayerInfo& res) const
{
    throw 3; // TODO
    /* assert(!FoundSolution() && !Bricked()); */
    /* assert(dead.dieIdx>=0 && alive.dieIdx<0); */

    /* int steps = alive.plan.size(); */
    /* assert(steps == (int)dead.plan.size()); */

    /* int from = GetUniformRandom(crossIdx, steps-1); */
    /* int n = std::geometric_distribution<int>(0.5f)(gen) % (steps-from); */
    /* int to = from+n; */

    /* // inherit player */
    /* res.plan = dead.plan; */
    /* res.dieCnt = dead.dieCnt; */

    /* for (int i = from; i <= to; ++i) */
    /* { */
    /*     assert (i >= 0 && i < steps); */
    /*     res.plan[i] = alive.plan[i]; */
    /* } */

    /* res.pruneProtect = true; */
}

bool Planner::Mutate(const PlayerInfo& player, PlayerInfo& mut)
{
    // TODO
    /* assert(!FoundSolution() && !Bricked()); */

    int lastIdx;
    float p;
    if (player.IsDead())
    {
        lastIdx = player.lastpos.size();
        p = 0.4f;
    }
    else
    {
        lastIdx = player.plan.size()-1;
        p = 0.3f;
    }

    /* mut = player; */
    int mutIdx = lastIdx - std::geometric_distribution<int>(p)(gen) % (lastIdx+1);
    Direction newdir = RandomOtherDirection(player.plan[mutIdx]);
    mut.plan = player.plan;
    mut.plan[mutIdx] = newdir;

    return Inherit(player, mut, mutIdx);
}

void Planner::StripOld()
{
    //! Not worth the time it takes to compute

    /* if ((int)players.size() <= samples) return; */

    /* auto it = std::partition(players.begin(), players.end(), [](const PlayerInfo& info) */
    /* { */
    /*     const int threshold = repeatGeneration; */
    /*     return info.dieCnt < threshold; */
    /* }); */
    /* int rem = it - players.begin(); */
    /* if (rem!=(int)players.size()) */
    /* { */
    /*     int n = players.end()-it; */
    /*     printf("%d players which do nothing:\n", n); */
    /*     printf("%lf percent\n", (float)n/players.size()); */
    /* } */
    /* int newsiz = std::max(rem, samples); */
    /* players.resize(newsiz); */
}

// key notes:
// maintain the ratio dead : alive, so as to give everyone an equal chance.
// both dead and alive players are valuable. Also give equal chance to everyone
// to have offspring. Otherwise, the players will behave the same.
int Planner::GenChildren(std::vector<PlayerInfo>& children, int nChildren)
{
    assert(!FoundSolution() && !Bricked());

    std::shuffle(players.begin(), players.end(), gen);
    auto it = std::partition(players.begin(), players.end(),
        [](const PlayerInfo& info)
        {
            return !info.IsDead();
        });

    children.clear();
    children.resize(nChildren);

    int nAlive = it-players.begin();
    int nDead = players.size()-nAlive;

    float ratioAlive = (float)nAlive/players.size();
    int newAlive = ceil(std::max(ratioAlive, playerMinAlive) * nChildren);
    int newDead = nChildren - newAlive;

    // WHAT IF NO CHLD? TODO
    assert(nAlive>=0 && nDead>=0);
    assert(newDead>=0);

    int idx = 0;
    for (int off = 0; off < newDead; ++off)
    {
        /* int bestAlive = -1; */
        /* int crossIdx = -1; */
        /* int diff = INT_MAX; */

        int currDead = (off % nDead) + nAlive;
        // TODO commented code below
        /* for (int currAlive = 0; currAlive < nAlive; ++currAlive) */
        /* { */
        /*     int tmpCrossIdx; */
        /*     int curr = EvalMatch(players[currDead], players[currAlive], tmpCrossIdx); */
        /*     if (curr < diff) */
        /*     { */
        /*         diff = curr; */
        /*         bestAlive = currAlive; */
        /*         crossIdx = tmpCrossIdx; */
        /*     } */
        /* } */

        /* const int threshold = 200; */
        /* if (diff < threshold && crossIdx < steps-2) // avoid copying parent completely / only copy if relevant */
        /*     CrossOver(players[currDead], players[bestAlive], crossIdx, children[idx++]); */
        /* else */
        /*     wonnered=Mutate(players[currDead], children[idx++]); */
        // TODO BIG NONO
        children[idx] = players[currDead].Mutate(gen);
        // TODO TESTING
        /* players[currDead] = children[idx]; */

        assert (!children[idx].HasNoPlan());
        if (children[idx].IsWinner()) res = children[idx].GetSolution(); // TODO
        ++idx;
    }

    for (int off = 0; off < newAlive; ++off)
    {
        int currAlive = off % nAlive;
        children[idx] = players[currAlive].Mutate(gen);
        assert (!children[idx].HasNoPlan());
        // TODO TESTING
        /* players[currAlive] = children[idx]; */

        if (children[idx].IsWinner()) res = children[idx].GetSolution(); // TODO
        ++idx;
        /* Mutate(players[i], children[idx++]); */
    }

    assert(idx==(int)children.size());
    /* if (players.size() < samples) */
    /* { */
    /*     for (int i = 0; i < 50; ++i) */
    /*     { */
    /*         children.push_back(PlayerInfo(steps, gen)); */
    /*         children.back().protection = 30; */
    /*     } */

    /* } */
    return nAlive;
}

#include <HardestGame.h>

const float offx = checkerLen*2;
const float offy = checkerLen*3;

static void OffsetIBox(IBox& b)
{
    b.xmin += offx;
    b.xmax += offx;
    b.ymin += offy;
    b.ymax += offy;
}

static void OffsetEnemyPath(EnemyPath& e)
{
    if (e.dir==UP || e.dir==DOWN)
    {
        e.from += offy;
        e.to += offy;
    }
    else if (e.dir==LEFT || e.dir==RIGHT)
    {
        e.from += offx;
        e.to += offx;
    }

    e.pos.x += offx;
    e.pos.y += offy;
};

static LevelDscr LoadLevel()
{
    LevelDscr lvl;
    lvl.area.emplace_back(180, 494, 45, 584);
    lvl.area.emplace_back(495, 809, 45, 134);
    lvl.area.emplace_back(810, 944, 45, 134);
    lvl.area.emplace_back(540, 629, 135, 584);
    lvl.area.emplace_back(630, 989, 495, 584);
    lvl.area.emplace_back(810, 944, 180, 494);
    lvl.area.emplace_back(810, 944, 135, 179);
    lvl.startIdx=0;
    lvl.endIdx=2;
    lvl.enemies.emplace_back(652, 112, 652, 787, Direction(8));
    lvl.enemies.emplace_back(787, 67, 652, 787, Direction(4));
    lvl.player=IBox(319, 343, 401, 425);
    return lvl;
}

/* static LevelDscr LoadLevel() */
/* { */
/*     LevelDscr lvl; */
/*     lvl.area.emplace_back(135, 404, 45, 539); */
/*     lvl.area.emplace_back(405, 719, 45, 134); */
/*     lvl.area.emplace_back(720, 854, 45, 134); */
/*     lvl.area.emplace_back(450, 584, 135, 539); */
/*     lvl.area.emplace_back(585, 854, 450, 539); */
/*     lvl.area.emplace_back(765, 854, 135, 449); */
/*     lvl.startIdx=0; */
/*     lvl.endIdx=2; */
/*     lvl.enemies.emplace_back(697, 112, 607, 697); */
/*     lvl.enemies.emplace_back(607, 67, 607, 697); */
/*     lvl.player=IBox(267, 291, 354, 378); */
/*     return lvl; */
/* } */

/* static LevelDscr LoadLevel() */
/* { */
/*     LevelDscr lvl; */

/*     lvl.area.emplace_back(0, 3*checkerLen-1, 0, 7*checkerLen-1); */

/*     /1* lvl.area.emplace_back(3*checkerLen, 5*checkerLen-1, 6*checkerLen, 7*checkerLen-1); *1/ */
/*     /1* lvl.area.emplace_back(4*checkerLen, 5*checkerLen-1, 5*checkerLen, 6*checkerLen-1); *1/ */

/*     lvl.area.emplace_back(5*checkerLen, 2*checkerLen, 6*checkerLen, 5*checkerLen); */

/*     /1* lvl.area.emplace_back(3*checkerLen, 5*checkerLen-1, 0, 1*checkerLen-1); *1/ */
/*     /1* lvl.area.emplace_back(4*checkerLen, 12*checkerLen-1, 1*checkerLen, 6*checkerLen-1); *1/ */
/*     /1* lvl.area.emplace_back(11*checkerLen, 13*checkerLen-1, 6*checkerLen, 7*checkerLen-1); *1/ */
/*     lvl.area.emplace_back(13*checkerLen, 16*checkerLen-1, 0, 7*checkerLen-1); */
/*     for (IBox& b : lvl.area) */
/*     { */
/*         OffsetIBox(b); */
/*     } */

/*     lvl.startIdx = 0; */
/*     lvl.endIdx = lvl.area.size()-1; */

/*     // standard */
/*     lvl.enemies.push_back({{11*checkerLen, int(1.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 12*checkerLen-enemyRad, LEFT}); */
/*     lvl.enemies.push_back({{5*checkerLen, int(2.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 12*checkerLen-enemyRad, RIGHT}); */
/*     lvl.enemies.push_back({{11*checkerLen, int(3.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 12*checkerLen-enemyRad, LEFT}); */
/*     lvl.enemies.push_back({{5*checkerLen, int(4.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 12*checkerLen-enemyRad, RIGHT}); */
/*     lvl.enemies.push_back({{11*checkerLen, int(5.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 12*checkerLen-enemyRad, LEFT}); */

/*     // standard vert */
/*     lvl.enemies.push_back({{int(4.5*checkerLen), int(5.5*checkerLen)}, */
/*             checkerLen+enemyRad, 6*checkerLen-enemyRad, DOWN}); */
/*     lvl.enemies.push_back({{int(6.5*checkerLen), int(3.5*checkerLen)}, */
/*             checkerLen+enemyRad, 6*checkerLen-enemyRad, UP}); */
/*     lvl.enemies.push_back({{int(8.5*checkerLen), int(1.5*checkerLen)}, */
/*             checkerLen+enemyRad, 6*checkerLen-enemyRad, DOWN}); */
/*     lvl.enemies.push_back({{int(10.5*checkerLen), int(3.5*checkerLen)}, */
/*             checkerLen+enemyRad, 6*checkerLen-enemyRad, DOWN}); */
/*     /1* lvl.enemies.push_back({{int(11.5*checkerLen), int(1.5*checkerLen)}, *1/ */
/*     /1*         checkerLen+enemyRad, 6*checkerLen-enemyRad, UP}); *1/ */

/*     // horiz wall */
/*     lvl.enemies.push_back({{5*checkerLen, int(3.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 5*checkerLen+enemyRad, LEFT}); */
/*     lvl.enemies.push_back({{6*checkerLen, int(3.5*checkerLen)}, */
/*             5*checkerLen+enemyRad, 6*checkerLen+enemyRad, LEFT}); */
/*     lvl.enemies.push_back({{7*checkerLen, int(3.5*checkerLen)}, */
/*             6*checkerLen+enemyRad, 7*checkerLen+enemyRad, LEFT}); */
/*     lvl.enemies.push_back({{8*checkerLen, int(3.5*checkerLen)}, */
/*             7*checkerLen+enemyRad, 8*checkerLen+enemyRad, LEFT}); */
/*     lvl.enemies.push_back({{9*checkerLen, int(3.5*checkerLen)}, */
/*             8*checkerLen+enemyRad, 9*checkerLen+enemyRad, LEFT}); */

/*     // vert wall */
/*     lvl.enemies.push_back({{int(9.5*checkerLen), int(5.5*checkerLen)}, */
/*             5*checkerLen+enemyRad, 6*checkerLen-enemyRad, UP}); */
/*     lvl.enemies.push_back({{int(9.5*checkerLen), int(4.5*checkerLen)}, */
/*             4*checkerLen+enemyRad, 5*checkerLen-enemyRad, UP}); */
/*     lvl.enemies.push_back({{int(9.5*checkerLen), int(3.5*checkerLen)}, */
/*             3*checkerLen+enemyRad, 4*checkerLen-enemyRad, UP}); */

/*     for (EnemyPath& p : lvl.enemies) */
/*     { */
/*         OffsetEnemyPath(p); */
/*     } */

/*     int startx = (lvl.area[lvl.startIdx].xmin+lvl.area[lvl.startIdx].xmax) / 2; */
/*     int starty = (lvl.area[lvl.startIdx].ymin+lvl.area[lvl.startIdx].ymax) / 2 + 3*checkerLen; */
/*     lvl.player.xmin = startx-playerRad; */
/*     lvl.player.xmax = startx+playerRad; */
/*     lvl.player.ymin = starty-playerRad; */
/*     lvl.player.ymax = starty+playerRad; */

/*     return lvl; */
/* } */

const LevelDscr& LevelDscr::Get()
{
    static LevelDscr lvl = LoadLevel();
    return lvl;
}
