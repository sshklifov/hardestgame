## Компилация

```
./build.sh
```
Приема и опция -f за force (за всеки случай).

## Изисквания

* glfw >= 3.0
* opengl >= 3.3
* glibc >= 2.0
* Каквито и да е pkg-config, make, makedepend

## Идея

В Movement пазя информация за clipping и логика дали играч умира или не. Използвам basic динамично програмиране,
за да улесня сметките.

В Draw се съдържат инструментите за чертаене на екрана - ниво, играчи и точки. В буфер записвам какво трябва да
излезне на екрана и с OpenGL чертая буфера като текстура. Прозорец създавам с GLFW.

В Main има:
* HardestGame хедъра
* LevelEditor, с който генерирах няколко level-a да тествам
* Main, който не прави нищо особено

В Planner се съдържа същината на проекта

## Planner

### PlayerInfo

##### member variables
Да започнем с PlayerInfo, това представлява играча. Най-важното за него е fitness и stability. fitness се изчислява
по следната логика:
* ако играч умре, получава много ниска оценка (по-ниска от всеки жив, но не просто INT\_MIN)
* ако играч стигне до края, INT\_MAX (буквално)
* ако най-късия път до края намалее или най-късия път от началото се увеличи, се увеличава и fitness.

С stability се имплементира simulated annealing. Това помага за избягвнето от локален минимум и има демо как работи.
Идеята е, че колкото по-нестабилен е играч, толкова по-вероятно е да разджуркаме ходовете му и е толкова по-вероятно
да ги приемем, дори и да водят до по-лош резултат.

Останалите полета са самия план, докъде е стигнал играча и един кеширащ вектор, който забърза сметките около двойно.
Когато създадем нов играч, няма нужда да симулираме ходовете му отначало, понеже те са до известна степен същите като
родителя му.

#### member functions
Методите са Mutation, който се опитва да промени играча (спрямо stability). Ако се повиши fitness-a, промяната се приема.
Ако не, с някаква вероятност се приема. Вероятността зависи от това колко по-лош е fitness-a и колко е нестабилен играча.
Crossover прави (несиметричен) cross. Избира се позиция къде спира единия родител и почва другия и се слепват ходовете им.
Тази позиция се избира в по-късните ходове на родителите.

### Planner
Борави с вектор от PlayerInfo. Започа с нисък брой ходове (както в клипчето) и постепенно ги увеличава. Вика Mutate на всеки
играч и Crossover на най-добрите от тях, като се създават ограничен брой нови играчи. Това се прави, защото операцията за
премахване на слаби играчи е скъпа. Тя първо премахва тези играчи, който се повтарят (има друг по-добър играч до тях в много
близо съседство). Ако все още има много играчи, ги филтрира по fitness.

### ParallelPlanner
Прави независими Planner-и и ги пуска за няколко поколения. След извествен брой поколения, слива всичи играчи, взима най-добрите
от тях и ги раздава на нишките. Така полезна информация от една нишка достига всички (теоретично). Тази операция не се прави
твърде често поради съобрежения за бързодействие. Нишките се пазят до края на живота на класа, т.е. не се унищожават и създават
периодично. На практика Parallel planner работи 10% по-бавно от Planner със същия брой семпли на нишка.
